case 'csend': {
  try {
    const argsText = args.join(" ");
    if (!argsText) {
      return reply("‚ùå Format ‡∂ë‡∂ö ‡∑Ä‡∑ê‡∂ª‡∂Ø‡∑í‡∂∫‡∑í!\nUse: `.csend <jid> <song name>`");
    }

    const targetJid = args[0];
    const query = args.slice(1).join(" ");

    if (!targetJid || !query || !targetJid.includes("@")) {
      return reply("‚ùå ‡∑Ä‡∑ê‡∂ª‡∂Ø‡∑í Format / JID!");
    }

    await socket.sendMessage(msg.key.remoteJid, {
      react: { text: "üéß", key: msg.key }
    });

    const yts = require("yt-search");
    const search = await yts(query);

    if (!search.videos.length) {
      return reply("‚ùå ‡∂ú‡∑ì‡∂≠‡∂∫ ‡∑Ñ‡∂∏‡∑î‡∂±‡∑ú‡∑Ä‡∑î‡∂´‡∑è!");
    }

    const video = search.videos[0];
    if (video.seconds > 600) {
      return reply("‚ùå ‡∂∏‡∑í‡∂±‡∑í‡∂≠‡∑ä‡∂≠‡∑î 10‡∂ß ‡∑Ä‡∂©‡∑è ‡∂Ø‡∑í‡∂ú ‡∂ú‡∑ì‡∂≠ support ‡∂±‡∑ú‡∂ö‡∂ª‡∂∫‡∑í!");
    }

    const ytUrl = video.url;

    const axios = require("axios");
    const apiUrl = `https://chama-yt-dl-api.vercel.app/mp3?id=${encodeURIComponent(ytUrl)}`;
    const { data } = await axios.get(apiUrl);

    if (!data?.downloadUrl) {
      return reply("‚ùå API error! ‡∂ú‡∑ì‡∂≠‡∂∫ ‡∂∂‡∑è‡∂ú‡∂≠ ‡∂ö‡∑Ö ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö.");
    }

    const fs = require("fs");
    const path = require("path");
    const ffmpeg = require("fluent-ffmpeg");
    const ffmpegPath = require("ffmpeg-static");
    ffmpeg.setFfmpegPath(ffmpegPath);

    const unique = Date.now();
    const mp3Path = path.join(__dirname, `temp_${unique}.mp3`);
    const opusPath = path.join(__dirname, `temp_${unique}.opus`);

    const mp3 = await axios.get(data.downloadUrl, { responseType: "arraybuffer" });
    fs.writeFileSync(mp3Path, Buffer.from(mp3.data));

    await new Promise((resolve, reject) => {
      ffmpeg(mp3Path)
        .audioBitrate(64)
        .audioCodec("libopus")
        .format("opus")
        .on("end", resolve)
        .on("error", reject)
        .save(opusPath);
    });

    let channelname = targetJid;
    try {
      const meta = await socket.groupMetadata(targetJid);
      if (meta?.subject) channelname = meta.subject;
    } catch {}

    const caption = `
‚ùù _${data.title}_ ‚ùû

*00:00 ‚îÄ‚îÄ‚îÄ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ${video.timestamp}*

* *‡∂î‡∂∫‡∑è ‡∂ö‡∑ê‡∂∏‡∂≠‡∑í‡∂∏ ‡∂¥‡∑è‡∂ß‡∑í‡∂±‡∑ä ‡∂ª‡∑í‡∂á‡∂ö‡∑ä‡∂ß‡∑ä ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ø‡∑è‡∂ú‡∑ô‡∂± ‡∂∫‡∂∏‡∑î‡∂Ø ‡∂Ω‡∑É‡∑ä‡∑É‡∂± ‡∑Ö‡∂∏‡∂∫‡∑ù ...üíóüòΩüçÉ*

* *Use headphones for best experience üéßüòå.*

* *https://zanta-bot.vercel.app/*

¬† ‚ô°¬†¬†¬†¬†¬†¬†¬†¬†¬† ‚éô¬†¬†¬†¬†¬†¬†¬†¬†¬† ‚û¶ 
 ≥·µâ·µÉ·∂ú·µó¬†¬†¬†¬†¬†¬† À¢·µÉ·µõ·µâ¬†¬†¬†¬†¬†¬† À¢ ∞·µÉ ≥·µâ

> ${channelname}`;

    await socket.sendMessage(targetJid, {
      image: { url: data.thumbnail },
      caption
    });

    await socket.sendMessage(targetJid, {
      audio: { url: opusPath },
      mimetype: "audio/ogg; codecs=opus",
      ptt: true
    });

    await socket.sendMessage(sender, {
      text: `‚úÖ *"${data.title}"* sent to *${channelname}* üé∂`
    });

    fs.unlinkSync(mp3Path);
    fs.unlinkSync(opusPath);

  } catch (e) {
    console.error(e);
    reply("‚ùå ‡∂Ø‡∑ù‡∑Ç‡∂∫‡∂ö‡∑ä ‡∂á‡∂≠‡∑í‡∑Ä‡∑î‡∂´‡∑è! ‡∂¥‡∑É‡∑î‡∑Ä ‡∂±‡∑ê‡∑Ä‡∂≠ ‡∂ã‡∂≠‡∑ä‡∑É‡∑Ñ ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.");
  }
  break;
}